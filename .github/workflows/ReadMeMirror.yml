name: Mirror README to Discord (edit if exists, fallback)

on:
  push:
    paths:
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          persist-credentials: true

      - name: Read README
        id: read
        run: |
          if [ ! -f README.md ]; then
            echo "README.md not found" >&2
            exit 1
          fi
          # escape triple backticks
          ESCAPED=$(sed 's/```/`​`​`/g' README.md)
          echo "content<<EOF" >> "$GITHUB_OUTPUT"
          echo "$ESCAPED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          LENGTH=$(wc -c < README.md)
          echo "length=$LENGTH" >> "$GITHUB_OUTPUT"

      - name: Parse webhook parts
        id: wb
        run: |
          FULL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          WEBHOOK_ID=$(echo "$FULL" | awk -F'/' '{print $(NF-1)}')
          WEBHOOK_TOKEN=$(echo "$FULL" | awk -F'/' '{print $NF}')
          echo "id=$WEBHOOK_ID" >> "$GITHUB_OUTPUT"
          echo "token=$WEBHOOK_TOKEN" >> "$GITHUB_OUTPUT"

      - name: Load existing message ID
        id: load
        run: |
          if [ -f .discord_message_id ]; then
            MSGID=$(cat .discord_message_id)
            echo "msgid=$MSGID" >> "$GITHUB_OUTPUT"
          else
            echo "msgid=" >> "$GITHUB_OUTPUT"
          fi

      - name: Post or patch message
        id: discord
        run: |
          set -e
          BASE="https://discord.com/api/webhooks/${{ steps.wb.outputs.id }}/${{ steps.wb.outputs.token }}"
          echo "Using webhook base: $BASE"
          CONTENT="${{ steps.read.outputs.content }}"
          LEN="${{ steps.read.outputs.length }}"
          OLD="${{ steps.load.outputs.msgid }}"

          # Prepare JSON payload
          JSON=$(jq -n --arg c "```$(printf '%s' \"$CONTENT\")```" '{ content: $c }')
          echo "Payload for Discord: $JSON"

          if [ -n "$OLD" ]; then
            # attempt edit
            RESP=$(curl -s -X PATCH \
              -H "Content-Type: application/json" \
              -d "$JSON" \
              "$BASE/messages/$OLD")
            echo "PATCH response: $RESP"
            NEWID=$(echo "$RESP" | jq -r '.id // empty')
            if [ -n "$NEWID" ]; then
              echo "Edited existing message $NEWID"
              echo "$NEWID" > .discord_message_id
              echo "new_msgid=$NEWID" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "PATCH failed or message not found, will POST new"
            fi
          fi

          # else fallback or first time
          RESP2=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "$JSON" \
            "$BASE?wait=true")
          echo "POST response: $RESP2"
          NEWID2=$(echo "$RESP2" | jq -r '.id // empty')
          if [ -n "$NEWID2" ]; then
            echo "Created new message $NEWID2"
            echo "$NEWID2" > .discord_message_id
            echo "new_msgid=$NEWID2" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "POST returned no message id; response was: $RESP2" >&2
            # fallback: send as file if embed fails
            curl -H "Content-Type: multipart/form-data" \
              -F "file=@README.md;filename=README.md" \
              -F "content=README (fallback file)" \
              "$BASE"
            exit 0
          fi

      - name: Commit .discord_message_id if changed
        if: steps.discord.outputs.new_msgid != ''
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add .discord_message_id
          git commit -m "Update Discord message ID" || echo "Nothing to commit"
          git push
