name: Mirror README to Discord (edit if exists, fallback)

on:
  push:
    paths:
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          persist-credentials: true

      - name: Read README
        id: read
        run: |
          if [ ! -f README.md ]; then
            echo "README.md not found" >&2
            exit 1
          fi
          # escape triple backticks
          ESCAPED=$(sed 's/```/`​`​`/g' README.md)
          echo "content<<EOF" >> "$GITHUB_OUTPUT"
          echo "$ESCAPED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          LENGTH=$(wc -c < README.md)
          echo "length=$LENGTH" >> "$GITHUB_OUTPUT"

      - name: Parse webhook parts
        id: wb
        run: |
          FULL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          WEBHOOK_ID=$(echo "$FULL" | awk -F'/' '{print $(NF-1)}')
          WEBHOOK_TOKEN=$(echo "$FULL" | awk -F'/' '{print $NF}')
          echo "id=$WEBHOOK_ID" >> "$GITHUB_OUTPUT"
          echo "token=$WEBHOOK_TOKEN" >> "$GITHUB_OUTPUT"

      - name: Load existing message ID
        id: load
        run: |
          if [ -f .discord_message_id ]; then
            MSGID=$(cat .discord_message_id)
            echo "msgid=$MSGID" >> "$GITHUB_OUTPUT"
          else
            echo "msgid=" >> "$GITHUB_OUTPUT"
          fi

      - name: Post header-sectioned messages
        id: discord
        run: |
          set -euo pipefail

          BASE="https://discord.com/api/webhooks/${{ steps.wb.outputs.id }}/${{ steps.wb.outputs.token }}"

          # Delete previous messages
          if [ -f .discord_message_ids ]; then
            echo "Deleting previous Discord messages..."
            while IFS= read -r MSGID; do
              if [ -n "$MSGID" ]; then
                curl -s -X DELETE "$BASE/messages/$MSGID" || true
              fi
            done < .discord_message_ids
          fi

          if [ ! -f README.md ]; then
            echo "ERROR: README.md not found!" >&2
            exit 2
          fi

          # Split on # or ## headers
          SECTIONS=()
          CURRENT=""
          while IFS= read -r LINE || [[ -n "$LINE" ]]; do
            if [[ "$LINE" =~ ^#{1,2}\ [^#] ]]; then
              if [[ -n "$CURRENT" ]]; then
                SECTIONS+=("$CURRENT")
              fi
              CURRENT="$LINE"
            else
              if [[ -n "$CURRENT" ]]; then
                CURRENT="$CURRENT"$'\n'"$LINE"
              else
                CURRENT="$LINE"  # leading content (unlikely in your case)
              fi
            fi
          done < README.md

          if [[ -n "$CURRENT" ]]; then
            SECTIONS+=("$CURRENT")
          fi

          echo "Split README into ${#SECTIONS[@]} sections."

          # Sanity check
          if [[ ${#SECTIONS[@]} -gt 10 ]]; then
            echo "Warning: ${#SECTIONS[@]} sections detected. This is unusual but proceeding."
          fi

          NEW_IDS=()
          for SECTION in "${SECTIONS[@]}"; do
            # Skip empty
            if [[ -z "$(printf '%s' "$SECTION" | tr -d '[:space:]')" ]]; then
              continue
            fi

            # Optional: escape backticks to prevent inline code issues
            CLEAN=$(printf '%s' "$SECTION" | sed 's/`/\\`/g')

            # Enforce Discord 2000-char limit
            if [[ ${#CLEAN} -gt 1990 ]]; then
              CLEAN="${CLEAN:0:1990}…"
            fi

            JSON=$(jq -cn --arg c "$CLEAN" '{ content: $c }')

            echo "Posting section (length: ${#CLEAN})..."

            ATTEMPTS=0
            while :; do
              RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -d "$JSON" \
                "${BASE}?wait=true")

              if echo "$RESP" | jq -e '.id?' >/dev/null 2>&1; then
                # Success
                NEWID=$(echo "$RESP" | jq -r '.id')
                NEW_IDS+=("$NEWID")
                break
              elif echo "$RESP" | jq -e '.message? | contains("rate limited")' >/dev/null; then
                RETRY=$(echo "$RESP" | jq -r '.retry_after // 1')
                echo "Rate limited by Discord. Waiting $RETRY seconds before retrying..."
                sleep "$RETRY"
                ATTEMPTS=$((ATTEMPTS+1))
                if (( ATTEMPTS > 5 )); then
                  echo "ERROR: Rate limited too many times, aborting." >&2
                  exit 12
                fi
              else
                echo "ERROR: Discord rejected message. Response: $RESP" >&2
                echo "Preview (first 100 chars): $(printf '%s' "$SECTION" | cut -c1-100)"
                exit 11
              fi
            done
          done

          printf "%s\n" "${NEW_IDS[@]}" > .discord_message_ids
          echo "new_msgids=$(IFS=,; echo "${NEW_IDS[*]}")" >> "$GITHUB_OUTPUT"
          echo "✅ Successfully posted ${#NEW_IDS[@]} messages to Discord."

      - name: Commit .discord_message_ids if changed
        if: steps.discord.outputs.new_msgids != ''
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add .discord_message_ids
          git commit -m "Update Discord message IDs" || echo "Nothing to commit"
          git push
