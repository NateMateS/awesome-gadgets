name: Mirror README to Discord (edit if exists, fallback)

on:
  push:
    paths:
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          persist-credentials: true

      - name: Read README
        id: read
        run: |
          if [ ! -f README.md ]; then
            echo "README.md not found" >&2
            exit 1
          fi
          # escape triple backticks
          ESCAPED=$(sed 's/```/`​`​`/g' README.md)
          echo "content<<EOF" >> "$GITHUB_OUTPUT"
          echo "$ESCAPED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          LENGTH=$(wc -c < README.md)
          echo "length=$LENGTH" >> "$GITHUB_OUTPUT"

      - name: Parse webhook parts
        id: wb
        run: |
          FULL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          WEBHOOK_ID=$(echo "$FULL" | awk -F'/' '{print $(NF-1)}')
          WEBHOOK_TOKEN=$(echo "$FULL" | awk -F'/' '{print $NF}')
          echo "id=$WEBHOOK_ID" >> "$GITHUB_OUTPUT"
          echo "token=$WEBHOOK_TOKEN" >> "$GITHUB_OUTPUT"

      - name: Load existing message ID
        id: load
        run: |
          if [ -f .discord_message_id ]; then
            MSGID=$(cat .discord_message_id)
            echo "msgid=$MSGID" >> "$GITHUB_OUTPUT"
          else
            echo "msgid=" >> "$GITHUB_OUTPUT"
          fi

      - name: Post or patch messages (chunked, fail-safe)
        id: discord
        run: |
          set -euo pipefail
          
          BASE="https://discord.com/api/webhooks/${{ steps.wb.outputs.id }}/${{ steps.wb.outputs.token }}"
          OLD_IDS=()
          if [ -f .discord_message_ids ]; then
            mapfile -t OLD_IDS < .discord_message_ids
          fi
          
          if [ ! -f README.md ]; then
            echo "ERROR: README.md not found!"
            exit 2
          fi
          
          # Safely split README.md into 1900-character chunks (do not execute or source its content)
          CONTENT=$(cat README.md)
          CHUNKS=()
          while [ "${#CONTENT}" -gt 0 ]; do
            CHUNKS+=( "${CONTENT:0:1900}" )
            CONTENT="${CONTENT:1900}"
          done
          
          # Print chunk information for debugging
          echo "Split README.md into ${#CHUNKS[@]} chunks."
          for i in "${!CHUNKS[@]}"; do
            echo "Chunk $i length: ${#CHUNKS[$i]}"
            echo "Chunk $i preview: $(echo "${CHUNKS[$i]}" | head -n 2)"
          done
          
          NEW_IDS=()
          NUM_CHUNKS=${#CHUNKS[@]}
          NUM_OLD=${#OLD_IDS[@]}
          
          for IDX in $(seq 0 $((NUM_CHUNKS-1))); do
            CHUNK="${CHUNKS[$IDX]}"
            JSON=$(jq -c -n --arg c "```${CHUNK}```" '{ content: $c }')
            echo "Posting chunk $IDX to Discord (length: ${#CHUNK})..."

            if [ $IDX -lt $NUM_OLD ] && [ -n "${OLD_IDS[$IDX]:-}" ]; then
              MSGID="${OLD_IDS[$IDX]}"
              RESP=$(curl -s -X PATCH \
                -H "Content-Type: application/json" \
                -d "$JSON" \
                "$BASE/messages/$MSGID")
              echo "Discord PATCH response: $RESP"
              NEWID=$(echo "$RESP" | jq -r '.id // empty')
              if [ -n "$NEWID" ]; then
                NEW_IDS+=("$NEWID")
              else
                echo "PATCH failed, trying POST for chunk $IDX"
                RESP=$(curl -s -X POST \
                  -H "Content-Type: application/json" \
                  -d "$JSON" \
                  "${BASE}?wait=true")
                echo "Discord POST response: $RESP"
                NEWID=$(echo "$RESP" | jq -r '.id // empty')
                if [ -z "$NEWID" ]; then
                  echo "ERROR: Discord POST failed for chunk $IDX. Response: $RESP"
                  exit 10
                fi
                NEW_IDS+=("$NEWID")
              fi
            else
              RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -d "$JSON" \
                "${BASE}?wait=true")
              echo "Discord POST response: $RESP"
              NEWID=$(echo "$RESP" | jq -r '.id // empty')
              if [ -z "$NEWID" ]; then
                echo "ERROR: Discord POST failed for chunk $IDX. Response: $RESP"
                exit 11
              fi
              NEW_IDS+=("$NEWID")
            fi
          done

          # Delete any extra old messages
          if [ $NUM_OLD -gt $NUM_CHUNKS ]; then
            for IDX in $(seq $NUM_CHUNKS $((NUM_OLD-1))); do
              MSGID="${OLD_IDS[$IDX]}"
              echo "Deleting extra Discord message $MSGID..."
              curl -s -X DELETE "$BASE/messages/$MSGID"
            done
          fi

          printf "%s\n" "${NEW_IDS[@]}" > .discord_message_ids
          echo "new_msgids=$(IFS=,; echo "${NEW_IDS[*]}")" >> "$GITHUB_OUTPUT"

          echo "All Discord message operations completed successfully!"

      - name: Commit .discord_message_ids if changed
        if: steps.discord.outputs.new_msgids != ''
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add .discord_message_ids
          git commit -m "Update Discord message IDs" || echo "Nothing to commit"
          git push
