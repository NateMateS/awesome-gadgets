name: Mirror README to Discord (live edit)

on:
  push:
    paths:
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write   # allow commit / pushing a file (for storing message ID)
  id-token: write    # optional, depending on how you want to store state

jobs:
  mirror:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          persist-credentials: true  # so push back is authenticated

      - name: Read README content
        id: read
        run: |
          if [ ! -f README.md ]; then
            echo "::error::README.md not found"
            exit 1
          fi
          # Escape backticks so Discord triple-backtick blocks don't break
          # This replaces ``` with `窶義窶義 (i.e. zero-width spaces in between)  
          CONTENT=$(sed 's/```/`窶義窶義/g' README.md)
          echo "$CONTENT" > readme_content.txt
          LENGTH=$(wc -c < readme_content.txt)
          echo "::set-output name=length::$LENGTH"
          # Cap stored content (just to avoid giant output issues)
          TRIM=$(head -c 200000 readme_content.txt)
          echo "::set-output name=content::$TRIM"

      - name: Prepare webhook URL parts
        id: webhook_parts
        run: |
          # Split webhook URL into ID and TOKEN parts
          # Example webhook: https://discord.com/api/webhooks/ID/TOKEN
          FULL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          # Extract the last two path segments
          WEBHOOK_ID=$(echo "$FULL" | awk -F'/' '{print $(NF-1)}')
          WEBHOOK_TOKEN=$(echo "$FULL" | awk -F'/' '{print $NF}')
          echo "::set-output name=id::$WEBHOOK_ID"
          echo "::set-output name=token::$WEBHOOK_TOKEN"

      - name: Load existing message ID (if any)
        id: load_msgid
        run: |
          if [ -f .discord_message_id ]; then
            MSGID=$(cat .discord_message_id)
            echo "::set-output name=msgid::$MSGID"
          else
            echo "::set-output name=msgid::"
          fi

      - name: Send or update Discord message
        id: discord_post
        run: |
          WEBHOOK_ID=${{ steps.webhook_parts.outputs.id }}
          WEBHOOK_TOKEN=${{ steps.webhook_parts.outputs.token }}
          BASE_URL="https://discord.com/api/webhooks/${WEBHOOK_ID}/${WEBHOOK_TOKEN}"

          CONTENT="${{ steps.read.outputs.content }}"
          LENGTH=${{ steps.read.outputs.length }}
          OLD_MSGID="${{ steps.load_msgid.outputs.msgid }}"

          # Build JSON payload
          # Here we wrap in triple backticks
          PAYLOAD=$( jq -n --arg c "```$CONTENT```" '{ "content": $c }' )

          if [ -n "$OLD_MSGID" ]; then
            # Try PATCH (edit) existing message
            RESP=$(curl -s -X PATCH \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$BASE_URL/messages/$OLD_MSGID")
            # If PATCH fails (say message deleted), fallback to POST
            if echo "$RESP" | jq -e '.id' > /dev/null; then
              echo "Edited message $OLD_MSGID"
              echo "::set-output name=new_msgid::$OLD_MSGID"
            else
              # fallback to new POST
              RESP2=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -d "$PAYLOAD" \
                "$BASE_URL")
              NEWID=$(echo "$RESP2" | jq -r '.id')
              echo "Created new message $NEWID"
              echo "::set-output name=new_msgid::$NEWID"
            fi
          else
            # No existing message -> send as new
            RESP=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$BASE_URL")
            NEWID=$(echo "$RESP" | jq -r '.id')
            echo "Created new message $NEWID"
            echo "::set-output name=new_msgid::$NEWID"
          fi

      - name: Fallback - send as file if too large
        if: steps.read.outputs.length > 1900
        run: |
          BASE="$BASE_URL"
          # Upload file instead (multipart/form-data)
          curl -H "Content-Type: multipart/form-data" \
            -F "file=@README.md;filename=README.md" \
            -F "content=Latest README (too large to embed)" \
            $BASE

      - name: Persist message ID locally
        if: steps.discord_post.outputs.new_msgid != ''
        run: |
          echo "${{ steps.discord_post.outputs.new_msgid }}" > .discord_message_id

      - name: Commit message ID back (optional)
        if: steps.discord_post.outputs.new_msgid != ''
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add .discord_message_id
          git commit -m "Update Discord message ID" || echo "No changes to commit"
          git push
